#!/bin/sh

ctl_=$FWM_HOME/.control$DISPLAY

normbg() { read normbg_ < $FWM_HOME/colors/normal-bg; }
normfg() { read normfg_ < $FWM_HOME/colors/normal-fg; }
selbg() { read selbg_ < $FWM_HOME/colors/active-bg; }
selfg() { read selfg_ < $FWM_HOME/colors/notice-fg; }
notebg() { read notebg_ < $FWM_HOME/colors/notice-bg; }
notefg() { read notefg_ < $FWM_HOME/colors/notice-fg; }

getpid()
{ # for dock $1:name for tool $1:prog $2:name
	local pwd=$PWD

	pid_=''
	cd /proc

	for pid in *; do
		if [ -f $pid/cmdline ]; then
			read cmd < $pid/cmdline

			if [ $# -eq 1 ]; then
				case $cmd in
				fwm-dock*$1*) pid_="$pid_ $pid";;
				esac
			else
				case $cmd in
				$1*$2*) pid_="$pid_ $pid";;
				esac
			fi
		fi
	done

	cd $pwd
}

stoptool()
{ # $1:prog $2:name
	getpid $@

	for pid in $pid_; do
		kill -9 $pid
	done
}

stopdock()
{ # $1:name
	getpid $1

	for pid in $pid_; do
		kill -9 $pid
	done
}

startdock()
{ # $1:name $2:icon $3:bg $4:fg $5:comm $6:text
	stopdock $1
	exec fwm-dock -n $1 -i $2 -bg $3 -fg $4 -c $5 $6 &
}

updatedock()
{ # $1:name $2:icon $3:color $4:text
	getpid $1

	for pid in $pid_; do
		printf "update-dock $pid $2 $3 $4" > $ctl_
	done
}

stopmon()
{ # $1:name
	ps -opid,args | while read pid cmd; do
		if [ $$ = "$pid" ]; then
			continue
		fi
		case $cmd in
		*$1*bin*sh*$1*) kill -9 $pid 2>&1;;
		esac
	done
}

signalmon() { stopdock $name_ $comm_; exit 0; }

initmon()
{ # $1:name $2:comm
	trap signalmon SIGINT SIGTERM SIGKILL
	stopmon $name_
}

startmenu()
{ # $@ all menu arguments except colors
	local colors

	normbg
	normfg
	selbg
	selfg

	colors="-0 $normfg_ -1 $normbg_ -2 $selfg_ -3 $selbg_"
	fwm-menu -n menu $colors $@
}

showinfo()
{ # $@ all menu arguments except colors
	local colors

	normbg
	normfg

	colors="-0 $normfg_ -1 $normbg_ -2 $normfg_ -3 $normbg_"
	fwm-menu -n menu $colors $@ >/dev/null
}
